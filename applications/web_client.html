<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能對話助手 (稳定版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* 你的CSS样式保持不变 */
        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f3f4f6; display: flex; justify-content: center; align-items: center; min-height: 100vh; color: #374151; padding: 1rem; }
        .container { background-color: white; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); width: 100%; max-width: 600px; display: flex; flex-direction: column; height: 95vh; }
        .btn { padding: 0.625rem 1.25rem; border-radius: 0.375rem; font-weight: 500; transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; }
        .btn:focus { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); }
        .btn-primary { background-color: #3b82f6; color: white; }
        .btn-primary:hover { background-color: #2563eb; }
        .btn-primary:disabled { background-color: #9ca3af; cursor: not-allowed; }
        .btn-secondary { background-color: #e5e7eb; color: #4b5563; }
        .btn-secondary:hover { background-color: #d1d5db; }
        .btn-danger { background-color: #ef4444; color: white; }
        .btn-danger:hover { background-color: #dc2626; }
        .input-text { border: 1px solid #d1d5db; padding: 0.625rem; border-radius: 0.375rem; width: 100%; margin-bottom: 1rem; box-shadow: inset 0 1px 2px 0 rgba(0,0,0,0.05); }
        .input-text:focus { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3); }
        .status { padding: 0.5rem; border-radius: 0.375rem; font-size: 0.875rem; word-wrap: break-word; }
        .status-info { background-color: #eff6ff; color: #3b82f6; }
        .status-success { background-color: #f0fdf4; color: #22c55e; }
        .status-error { background-color: #fef2f2; color: #ef4444; }
        .hidden { display: none; }
        h1 { font-size: 1.75rem; font-weight: 600; margin-bottom: 1rem; text-align: center; color: #111827; }
        label { display: block; margin-bottom: 0.25rem; font-weight: 500; color: #4b5563; }
        #chatArea { flex-grow: 1; overflow-y: auto; border: 1px solid #e5e7eb; padding: 1rem; border-radius: 0.5rem; background-color: #f9fafb; margin-bottom: 1rem; display: flex; flex-direction: column; }
        .message-container { display: flex; margin-bottom: 0.75rem; width: 100%; }
        .message-container.user { justify-content: flex-end; }
        .message-container.bot { justify-content: flex-start; }
        .message-container.system { justify-content: center; }
        .message-bubble { max-width: 85%; padding: 0.75rem 1.125rem; border-radius: 1.25rem; word-wrap: break-word; position: relative; font-size: 0.9rem; line-height: 1.5; }
        .message-bubble.user { background-color: #2563eb; color: white; border-bottom-right-radius: 0.375rem; }
        .message-bubble.bot { background-color: #e5e7eb; color: #1f2937; border-bottom-left-radius: 0.375rem; }
        .message-text p:last-child { margin-bottom: 0; }
    </style>
</head>
<body>
    <div class="container">
        <!-- 你的HTML结构保持不变 -->
        <div class="flex-shrink-0">
            <h1>智能對話助手</h1>
            <div class="grid grid-cols-2 gap-4 mb-2">
                <div>
                    <label for="wsUrlInput">WebSocket URL:</label>
                    <input type="text" id="wsUrlInput" class="input-text !mb-0" value="ws://127.0.0.1:8765">
                </div>
                 <div>
                    <label for="clientSessionIdInput">會話ID (UUID):</label>
                    <div class="flex">
                        <input type="text" id="clientSessionIdInput" class="input-text !mb-0" readonly>
                        <button id="generateUuidButton" class="btn btn-secondary text-sm py-1 px-2 ml-2">新ID</button>
                    </div>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-2">
                 <button id="connectButton" class="btn btn-primary w-full">連接</button>
                 <button id="disconnectButton" class="btn btn-secondary w-full hidden">斷開連接</button>
            </div>
            <div id="statusArea" class="status status-info text-center">狀態：未連接</div>
        </div>
        <div id="chatArea"></div>
        <div class="flex-shrink-0">
            <textarea id="textInput" class="input-text" rows="2" placeholder="請先連接伺服器..." title="文本輸入框"></textarea>
            <div class="flex items-center">
                <button id="sendTextButton" class="btn btn-primary mr-2 flex-grow" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-send-fill mr-2" viewBox="0 0 16 16"><path d="M15.964.686a.5.5 0 0 0-.65-.65L.767 5.855H.766l-.452.18a.5.5 0 0 0-.082.887l.41.26.001.002 4.995 3.178 3.178 4.995.002.002.26.41a.5.5 0 0 0 .886-.083zm-1.833 1.89L6.637 10.07l-.215-.338a.5.5 0 0 0-.154-.154l-.338-.215 7.494-7.494 1.178-.471z"/></svg>
                    發送
                </button>
                <button id="startRecordButton" class="btn btn-primary" disabled title="开始录音">
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-mic-fill" viewBox="0 0 16 16"><path d="M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0z"/><path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5"/></svg>
                </button>
                <button id="stopRecordButton" class="btn btn-danger hidden" title="停止录音">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stop-fill" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5"/></svg>
                </button>
            </div>
            <div id="audioPlaybackStatus" class="status status-info mt-2 text-center">播放器: 空閒</div>
        </div>
    </div>

    <!-- AudioWorklet 处理器脚本 -->
    <script id="worklet-script" type="javascript/worklet">
    class AudioStreamerProcessor extends AudioWorkletProcessor {
        constructor(options) {
            super(options);
            // 从构造函数选项中获取采样率
            this.inputSampleRate = options.processorOptions.inputSampleRate;
            this.outputSampleRate = options.processorOptions.outputSampleRate;
            this.resampleRatio = this.inputSampleRate / this.outputSampleRate;
        }

        // 线性插值重采样
        resample(input) {
            if (this.resampleRatio === 1) return input;
            const outputLength = Math.floor(input.length / this.resampleRatio);
            if (outputLength === 0) return new Float32Array(0);

            const output = new Float32Array(outputLength);
            for (let i = 0; i < outputLength; i++) {
                const P = i * this.resampleRatio;
                const K = Math.floor(P);
                const T = P - K;
                const p1 = input[K] || 0;
                const p2 = input[K + 1] || 0;
                output[i] = p1 + (p2 - p1) * T;
            }
            return output;
        }

        // 将 Float32 (-1.0 to 1.0) 转换为 Int16 (-32768 to 32767)
        floatTo16BitPCM(input) {
            const output = new Int16Array(input.length);
            for (let i = 0; i < input.length; i++) {
                const s = Math.max(-1, Math.min(1, input[i]));
                output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return output;
        }

        process(inputs, outputs, parameters) {
            const inputData = inputs[0]?.[0];
            if (!inputData) return true; // 如果没有输入数据，继续运行

            // 1. 重采样到目标采样率
            const resampled = this.resample(inputData);
            if (resampled.length === 0) return true;

            // 2. 转换为16位PCM格式
            const pcmData = this.floatTo16BitPCM(resampled);

            // 3. 将处理后的二进制数据发送回主线程
            this.port.postMessage(pcmData.buffer, [pcmData.buffer]);

            return true; // 保持处理器活动状态
        }
    }
    registerProcessor('audio-streamer-processor', AudioStreamerProcessor);
    </script>


    <script>
        window.addEventListener('load', () => {
            // DOM Elements
            const wsUrlInput = document.getElementById('wsUrlInput');
            const connectButton = document.getElementById('connectButton');
            const disconnectButton = document.getElementById('disconnectButton');
            const clientSessionIdInput = document.getElementById('clientSessionIdInput');
            const generateUuidButton = document.getElementById('generateUuidButton');
            const textInput = document.getElementById('textInput');
            const sendTextButton = document.getElementById('sendTextButton');
            const startRecordButton = document.getElementById('startRecordButton');
            const stopRecordButton = document.getElementById('stopRecordButton');
            const statusArea = document.getElementById('statusArea');
            const chatArea = document.getElementById('chatArea');
            const audioPlaybackStatus = document.getElementById('audioPlaybackStatus');

            // Global State
            let websocket = null;
            let audioContext = null;
            let mediaStreamSource = null;
            let workletNode = null;
            let isRecording = false;

            let audioPlayer = new Audio();
            let audioQueue = [];
            let isPlayingFromQueue = false;
            let currentBotMessageBubble = null;
            let currentFullMarkdownText = '';
            let currentUserMessageBubble = null;
            const clientTagId = 'web_client_tag_' + Math.random().toString(36).substr(2, 5);

            // Constants
            const TARGET_AUDIO_SAMPLE_RATE = 16000;
            const EventType = {
                CLIENT_TEXT_INPUT: "CLIENT_TEXT_INPUT",
                SERVER_TEXT_RESPONSE: "SERVER_TEXT_RESPONSE",
                SERVER_AUDIO_RESPONSE: "SERVER_AUDIO_RESPONSE",
                SERVER_SYSTEM_MESSAGE: "SERVER_SYSTEM_MESSAGE",
                SYSTEM_CLIENT_SESSION_START: "SYSTEM_CLIENT_SESSION_START",
                SYSTEM_SERVER_SESSION_START: "SYSTEM_SERVER_SESSION_START",
                CLIENT_SPEECH_END: "CLIENT_SPEECH_END",
                STREAM_END: "STREAM_END",
                ASR_UPDATE: "ASR_UPDATE",
            };

            // --- Core Functions ---
            function updateStatus(message, type = 'info') {
                statusArea.textContent = `狀態：${message}`;
                statusArea.className = `status status-${type} text-center`;
            }

            function updateAudioPlaybackStatus(message) {
                audioPlaybackStatus.textContent = `播放器: ${message}`;
            }

            function generateAndSetUuid() {
                const newUuid = self.crypto.randomUUID();
                clientSessionIdInput.value = newUuid;
                localStorage.setItem('clientSessionIdForChatbot', newUuid);
                return newUuid;
            }

            marked.setOptions({ gfm: true, breaks: true, pedantic: false });

            function finalizePreviousBotMessage() {
                if (currentBotMessageBubble) {
                    const messageTextDiv = currentBotMessageBubble.querySelector('.message-text');
                    if (messageTextDiv && currentFullMarkdownText) {
                        messageTextDiv.innerHTML = marked.parse(currentFullMarkdownText);
                    }
                }
                currentBotMessageBubble = null;
                currentFullMarkdownText = '';
            }

            function appendMessageToDisplay(text, type, isFinal = true) {
                if (type !== 'bot') finalizePreviousBotMessage();
                if (type === 'bot') {
                    if (!currentBotMessageBubble) {
                        const messageContainer = document.createElement('div');
                        messageContainer.classList.add('message-container', 'bot');
                        const bubble = document.createElement('div');
                        bubble.classList.add('message-bubble', 'bot');
                        const messageTextDiv = document.createElement('div');
                        messageTextDiv.classList.add('message-text');
                        bubble.appendChild(messageTextDiv);
                        messageContainer.appendChild(bubble);
                        chatArea.appendChild(messageContainer);
                        currentBotMessageBubble = bubble;
                        currentFullMarkdownText = '';
                    }
                    currentFullMarkdownText += text;
                    const messageTextDiv = currentBotMessageBubble.querySelector('.message-text');
                    if (messageTextDiv) messageTextDiv.innerHTML = marked.parse(currentFullMarkdownText);
                    if (isFinal) {
                        finalizePreviousBotMessage();
                    }
                } else {
                     const messageContainer = document.createElement('div');
                    messageContainer.classList.add('message-container', type);
                    const bubble = document.createElement('div');
                    bubble.classList.add('message-bubble', type);
                    bubble.textContent = text;
                    messageContainer.appendChild(bubble);
                    chatArea.appendChild(messageContainer);
                }
                chatArea.scrollTop = chatArea.scrollHeight;
            }

            function playAudioFromQueue() {
                if (isPlayingFromQueue || audioQueue.length === 0) return;
                isPlayingFromQueue = true;
                const audioDataUrl = audioQueue.shift();
                audioPlayer.src = audioDataUrl;
                updateAudioPlaybackStatus("正在播放...");
                audioPlayer.play().catch(e => {
                    console.error("音频播放失败:", e);
                    updateAudioPlaybackStatus(`播放错误: ${e.message}`);
                    isPlayingFromQueue = false;
                });
            }
            audioPlayer.onended = () => {
                updateAudioPlaybackStatus("空闲");
                isPlayingFromQueue = false;
                playAudioFromQueue();
            };
            audioPlayer.onpause = () => {
                 if (isPlayingFromQueue) {
                    updateAudioPlaybackStatus("已打断");
                    isPlayingFromQueue = false;
                 }
            };

            function connectWebSocket() {
                const wsUrl = wsUrlInput.value;
                if (websocket && websocket.readyState === WebSocket.OPEN) return;
                updateStatus('正在連接...', 'info');
                websocket = new WebSocket(wsUrl);
                websocket.binaryType = "arraybuffer";
                websocket.onopen = () => {
                    updateStatus('連接成功', 'success');
                    connectButton.classList.add('hidden');
                    disconnectButton.classList.remove('hidden');
                    sendTextButton.disabled = false;
                    startRecordButton.disabled = false;
                    textInput.placeholder = "請輸入消息...";
                    const initMessage = {
                        event_type: EventType.SYSTEM_CLIENT_SESSION_START,
                        tag_id: clientTagId,
                        session_id: clientSessionIdInput.value
                    };
                    websocket.send(JSON.stringify(initMessage));
                    appendMessageToDisplay(`已發送會話初始化請求 (ID: ${clientSessionIdInput.value})`, 'system');
                };
                websocket.onmessage = (event) => {
                    if (typeof event.data === 'string') {
                        try {
                            const jsonData = JSON.parse(event.data);
                            const eventType = jsonData.event_type;
                            const eventData = jsonData.event_data;
                            switch (eventType) {
                                case EventType.SYSTEM_SERVER_SESSION_START:
                                    const newSessionId = jsonData.session_id;
                                    clientSessionIdInput.value = newSessionId;
                                    localStorage.setItem('clientSessionIdForChatbot', newSessionId);
                                    appendMessageToDisplay(`伺服器已確認會話 (ID: ${newSessionId})`, 'system');
                                    break;
                                case EventType.SERVER_TEXT_RESPONSE:
                                    appendMessageToDisplay(eventData.text || '', 'bot', eventData.is_final);
                                    break;
                                case EventType.ASR_UPDATE:
                                    if (!currentUserMessageBubble) {
                                        const messageContainer = document.createElement('div');
                                        messageContainer.className = 'message-container user';
                                        currentUserMessageBubble = document.createElement('div');
                                        currentUserMessageBubble.className = 'message-bubble user';
                                        messageContainer.appendChild(currentUserMessageBubble);
                                        chatArea.appendChild(messageContainer);
                                    }
                                    currentUserMessageBubble.textContent = eventData.text || '...';
                                    chatArea.scrollTop = chatArea.scrollHeight;
                                    if (eventData.is_final) {
                                        currentUserMessageBubble = null;
                                    }
                                    break;
                                case EventType.SERVER_AUDIO_RESPONSE:
                                    if (eventData && typeof eventData.data === 'string') {
                                        const audioDataUrl = `data:audio/wav;base64,${eventData.data}`;
                                        audioQueue.push(audioDataUrl);
                                        playAudioFromQueue();
                                    }
                                    break;
                            }
                        } catch (e) { console.error("解析伺服器 JSON 消息失敗:", e, event.data); }
                    }
                };
                websocket.onclose = () => {
                    updateStatus('已斷開連接', 'info');
                    websocket = null;
                    connectButton.classList.remove('hidden');
                    disconnectButton.classList.add('hidden');
                    sendTextButton.disabled = true;
                    startRecordButton.disabled = true;
                    stopRecording(false);
                    finalizePreviousBotMessage();
                };
            }

            function disconnectWebSocket() { if (websocket) websocket.close(); }

            async function startRecording() {
                if (isRecording) return;

                try {
                    // 1. 获取麦克风权限并创建音频上下文
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // 打断逻辑
                    if (!audioPlayer.paused) {
                        audioPlayer.pause();
                        audioQueue = [];
                    }

                    // 2. 创建 AudioWorklet
                    const workletScriptBlob = new Blob([document.getElementById('worklet-script').textContent], { type: 'application/javascript' });
                    const workletURL = URL.createObjectURL(workletScriptBlob);
                    await audioContext.audioWorklet.addModule(workletURL);

                    workletNode = new AudioWorkletNode(audioContext, 'audio-streamer-processor', {
                        processorOptions: {
                            inputSampleRate: audioContext.sampleRate,
                            outputSampleRate: TARGET_AUDIO_SAMPLE_RATE
                        }
                    });

                    // 3. 设置消息处理
                    workletNode.port.onmessage = (event) => {
                        // event.data 是一个 ArrayBuffer (Int16)
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            websocket.send(event.data);
                        }
                    };

                    // 4. 连接音频流
                    mediaStreamSource = audioContext.createMediaStreamSource(stream);
                    mediaStreamSource.connect(workletNode);
                    // workletNode 不需要连接到 destination，因为我们不想听到自己的声音

                    isRecording = true;
                    startRecordButton.classList.add('hidden');
                    stopRecordButton.classList.remove('hidden');
                    updateStatus("正在录音...", 'success');
                    appendMessageToDisplay('录音已开始...', 'system');

                } catch (err) {
                    console.error("麦克风或AudioWorklet初始化失败:", err);
                    appendMessageToDisplay(`错误: ${err.message}`, 'system');
                    stopRecording(false);
                }
            }

            function stopRecording(sendEndSignal = true) {
                if (mediaStreamSource) {
                    mediaStreamSource.mediaStream.getTracks().forEach(track => track.stop());
                    mediaStreamSource = null;
                }
                if (workletNode) {
                    workletNode.disconnect();
                    workletNode = null;
                }
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }

                if (sendEndSignal && websocket && websocket.readyState === WebSocket.OPEN) {
                    // 发送一个流结束的信号，让后端知道可以清理资源了
                    websocket.send(JSON.stringify({ event_type: EventType.STREAM_END }));
                    console.log("已发送 STREAM_END 事件");
                }

                isRecording = false;
                currentUserMessageBubble = null;
                startRecordButton.classList.remove('hidden');
                stopRecordButton.classList.add('hidden');
                updateStatus('录音已停止', 'info');
            }

            // Event Listeners
            connectButton.onclick = connectWebSocket;
            disconnectButton.onclick = disconnectWebSocket;
            generateUuidButton.onclick = generateAndSetUuid;
            startRecordButton.onclick = startRecording;
            stopRecordButton.onclick = stopRecording;

            sendTextButton.onclick = () => {
                const text = textInput.value.trim();
                if (text && websocket && websocket.readyState === WebSocket.OPEN) {
                    appendMessageToDisplay(text, 'user');
                    const message = {
                        event_type: EventType.CLIENT_TEXT_INPUT,
                        tag_id: clientTagId,
                        event_data: { text: text },
                        session_id: clientSessionIdInput.value
                    };
                    websocket.send(JSON.stringify(message));
                    textInput.value = '';
                }
            };
            textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendTextButton.click();
                }
            });

            // Initialize
            clientSessionIdInput.value = localStorage.getItem('clientSessionIdForChatbot') || generateAndSetUuid();
        });
    </script>
</body>
</html>
